<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Set Matrix Zeroes]]></title>
    <url>%2F2019%2F05%2F27%2FSet-Matrix-Zeroes%2F</url>
    <content type="text"><![CDATA[问题描述 给矩阵置0，就是找矩阵中为0的元素，将其同行同列置0,必须是就地算法（in-place） Example 1: input: [ [1,1,1], [1,0,1], [1,1,1] ] output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 整体思路思路1.0版本，朴素想法最朴素想法，先找为0的坐标，然后将其同行同列置0。这里有个小trick，找到为0的地方不能立即置0，下侧和右侧会导致判断失误。 代码1.0123456789101112131415161718192021222324252627282930 private void setZeroes(int[][] matrix) &#123; //最朴素想法，先找，然后置0 //注意：置0不能影响后面 HashSet&lt;Integer&gt; row = new HashSet&lt;&gt;(), col = new HashSet&lt;&gt;(); if (matrix.length==0) return; int m = matrix.length, n = matrix[0].length; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j]==0)&#123;// 填充0 row.add(i); col.add(j); &#125; &#125; &#125;// 置0 for (int i : row) &#123; for (int k = 0; k &lt; n; k++) matrix[i][k] = 0; &#125; for (int j : col) &#123; for (int k = 0; k &lt; m; k++)&#123; matrix[k][j] = 0; &#125; &#125; for (int[] nums : matrix) &#123; System.out.println(Arrays.toString(nums)); &#125; &#125; 思路2.0版本上个版本肯定是不work的啦，毕竟最朴素想法时空只能打败30%左右的样子。作为一个never setter的人，怎么能容忍这么高的时空复杂度。上一种方法空间复杂度为O(m*n),我想办法降到O(1)。注意到当检查到matrix[i][j] == 0 ,不能直接所有行 列置0的原因是会影响下侧和右侧的判断。但是上侧和左侧不会影响，故我们不再使用HashMap，直接将matrix[i][0] = matrix[0][j] = 0 ,然后再检查一下行列开头即可。注意如果本来第0行或者第0列就有0，需要用一个flag来记忆一下，然后再判定置0。 代码2.0123456789101112131415161718192021222324252627282930313233343536373839404142private void setZeroes2(int[][] matrix)&#123; int m = matrix.length, n = matrix[0].length; boolean isCol = false, isRow = false; for (int k = 0; k&lt;m; ++k)&#123; if (matrix[k][0] == 0) &#123; isCol = true; // 第一列应当置0 break; &#125; &#125; for (int k = 0; k&lt;n; ++k)&#123; if (matrix[0][k] == 0)&#123; isRow = true; // 第一行应当置0 break; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j]==0)&#123;// 填充0 matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for (int i = 1; i&lt;m; i++)&#123; if (matrix[i][0] == 0)&#123; for (int j = 1; j&lt;n; ++j) matrix[i][j] = 0; &#125; &#125; for (int j = 1; j&lt;n; j++)&#123; if (matrix[0][j] == 0)&#123; for (int i = 1; i&lt;m; ++i) matrix[i][j] = 0; &#125; &#125; if (isRow) for (int k = 0; k&lt;n; ++k) matrix[0][k] = 0; if (isCol) for (int k = 0; k&lt;m; ++k) matrix[k][0] = 0; for (int[] nums : matrix) &#123; System.out.println(Arrays.toString(nums)); &#125; &#125; 中等题就是这样，解出来比较简单，但是想要拿个top还是比较难的。不管怎样，第二种解法也是top 98%的存在。那么就来个九转大肠鼓励一下自己吧！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular Expression Matching]]></title>
    <url>%2F2019%2F05%2F26%2FRegular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[问题描述字符匹配问题 用p来匹配s. p中可能包含. * . 表示匹配任一个单一字符 * 表示匹配0到多个前一个字符 要求p和s匹配 Example 1: Input: s=”aa”p = “a” Output: false Explanation: “a” does not match the entire string “aa” Example 2: Input: s=”aa”p = “a*” Output: true Explanation: “‘*’ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa” Example 3: Input: s=”aab”p = “c*a*b” Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”. 思路这是一道非常困难的题, 曾经害我苦思冥想了好几天。我刚开始甚至没想到居然能用DP解这个问题，后来苦苦求索翻阅leetcode一众大神的解释后才搞明白这个题用DP到底怎么搞这是一道true false dp问题, dp[i][j] 表示了s前i个元素和p前j个元素的匹配情况分情况讨论： 如果s[i] == p [j] || p[j] == ‘.’这时候完全就看前面的情况 dp[i][j] = dp[i-1][j-1] 如果s[i] != p [j]这个也要分情况 2.1 如果p[j] == ‘*‘ (ba a* ab a*) 2.1.1 若 p[j-1] != s[i] &amp;&amp; p[j-1] != ‘.’此时, 由于上一个元素不匹配导致*无法复制，那么*只能让上一个元素清空: dp[i][j] = dp[i][j-2] 2.1.2 除上面的情况外，即*可以复制上一个元素达到匹配的目的，当然也可以不复制上一个元素: dp[i][j] = dp[i][j-2] (上一个元素清空) || dp[i][j-1] (\只代表一个元素) || dp[i-1][j] (代表多个元素，如果在i前面都能和p匹配，那加一个自然也能匹配*) 2.2 如果p[j] != ‘*’ dp[i][j] = false 特别解释一下，为什么在2.1.2中，当代表多个元素时，匹配的是dp[i-1][j]这个奇怪的搭配。让我们来举个栗子:假设我们的有 s: abbbbbp: cb* 我们看到这里的*，实际上是代表了5个b,但是当我们求dp[i][j]的时候，我们无法得匹配完这些b之后前面的元素是否匹配，我们删掉这些b s: ap: c 也就是说，a,c是否匹配已经在之前迭代了。如何得知a,c的迭代位置呢？ dp[i][j] = dp[i-1][j] = …… = dp[i-6][j] 这是通过我们之前已经求到的结果迭代出来的，你会发现i递减的过程其实就是在找重复元素之前的元素，所以我们直接给出了dp[i-1][j] 标准代码其实如果能看懂上面的解释的话，代码不成问题，上面的解释已经接近于伪代码了。12345678910111213141516171819202122public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; // s为空, p为空 dp[0][0] = true; // s为空， p不空 for (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j-1)=='*' &amp;&amp; dp[0][j-2]) dp[0][j] = true; &#125; //s不空，p空，直接默认false for (int i = 1; i &lt; s.length() + 1; i++) &#123; for (int j = 1; j &lt; p.length() + 1; j++) &#123; if (s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='.') dp[i][j] = dp[i-1][j-1]; else &#123; if (p.charAt(j-1)=='*')&#123; if (p.charAt(j-2)!=s.charAt(i-1)&amp;&amp;p.charAt(j-2)!='.') dp[i][j] = dp[i][j-2]; else dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j]; &#125; &#125; &#125; &#125; return dp[s.length()][p.length()]; &#125; 终于啃完这个头疼的问题了，看张图片奖励下自己吧]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ClimbingStairs]]></title>
    <url>%2F2019%2F05%2F25%2FClimbingStairs%2F</url>
    <content type="text"><![CDATA[问题描述这道题是easy题：You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? example1:Input: 2Output: 2Explanation: 1 step + 1 step 2 steps example2:Input: 3Output: 3Explanation: 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step 思路这个就很简单了, 典型的计数型动态规划问题，常规做法：记dp[n] 表示到高度n有dp[n]种方法，则dp[n] = dp[n-1]+dp[n-2]边界：dp[0] = 1 dp[1] = 2计算顺序：从左到右 代码1234567891011public int climbStairs(int n) &#123; int[] dp = new int[n]; dp[0] = 1; if (n&gt;1) dp[1] = 2; if (n&gt;2)&#123; for (int i = 2; i &lt; n; i++) &#123; dp[i] = dp[i-1]+dp[i-2]; &#125; &#125; return dp[n-1]; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孔雀东南飞（中文测试）]]></title>
    <url>%2F2019%2F05%2F24%2F%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[汉末建安中，庐江府小吏焦仲卿妻刘氏，为仲卿母所遣，自誓不嫁。其家逼之，乃投水而死。仲卿闻之，亦自缢于庭树。时人伤之，为诗云尔。 孔雀东南飞，五里一徘徊。 十三能织素6，十四学裁衣，十五弹箜篌7，十六诵诗书8。十七为君妇，心中常苦悲。君既为府吏，守节9情不移。贱妾留空房，相见常日稀。鸡鸣入机织，夜夜不得息。三日断10五匹，大人故嫌迟11。非为织作迟，君家妇难为！妾不堪12驱使，徒13留无所施14。便可白公姥15，及时相遣归 府吏得闻之，堂上启阿母：“儿已薄禄相16，幸复得此妇，结发17同枕席，黄泉共为友。共事二三年，始尔18未为久。女行无偏斜，何意致不厚19？” 阿母谓府吏：“何乃太区区20！此妇无礼节，举动自专由21。吾意久怀忿，汝岂得自由！东家有贤22女，自名秦罗敷，可怜23体无比，阿母为汝求。便可速遣之，遣去慎莫留！” 府吏长跪告：“伏惟24启阿母，今若遣此妇，终老不复取25！” 阿母得闻之，槌床26便大怒：“小子无所畏，何敢助妇语！吾已失恩义，会不相从许27！” 府吏默无声，再拜还入户。举言28谓新妇29，哽咽不能语：“我自不驱卿，逼迫有阿母。卿但暂还家，吾今且报府30。不久当归还，还必相迎取。以此下心意31，慎勿违吾语。” 新妇谓府吏：“勿复重纷纭32。往昔初阳岁33，谢34家来贵门。奉事循公姥，进止敢自专？昼夜勤作息35，伶俜萦苦辛36。谓言37无罪过，供养卒38大恩；仍更被驱遣，何言复来还！妾有绣腰襦39，葳蕤40自生光；红罗复斗帐，四角垂香囊；箱帘41六七十，绿碧青丝绳，物物各自异，种种在其中。人贱物亦鄙，不足迎后人42，留待作遗施43，于今无会因44。时时为安慰，久久莫相忘！” 鸡鸣外欲曙，新妇起严妆45。著我绣夹裙，事事四五通46。足下蹑47丝履，头上玳（dài）瑁（mào）48光。腰若流纨素，耳著明月珰49。指如削葱根，口如含朱丹。纤纤作细步，精妙世无双。 上堂拜阿母，阿母怒不止。“昔作女儿时50，生小出野里51。本自无教训，兼愧52贵家子。受母钱帛多，不堪母驱使。今日还家去，念母劳家里。”却53与小姑别，泪落连珠子。“新妇初来时，小姑始扶床；今日被驱遣，小姑如我长。勤心养公姥，好自相扶将54。初七及下九55，嬉戏莫相忘。”出门登车去，涕落百余行。 府吏马在前，新妇车在后。隐隐56何甸甸，俱会大道口。下马入车中，低头共耳语：“誓不相隔卿，且暂还家去；吾今且赴府，不久当还归。誓天不相负！”57 新妇谓府吏：“感君区区58怀！君既若见录59，不久望君来。君当作磐石，妾当作蒲苇，蒲苇纫60如丝，磐石无转移。我有亲父兄61，性行暴如雷，恐不任我意，逆62以煎我怀。”举手长劳劳63，二情同依依。 入门上家堂，进退无颜仪64。阿母大拊掌65，不图子自归66：“十三教汝织，十四能裁衣，十五弹箜篌，十六知礼仪，十七遣汝嫁，谓言无誓违67。汝今何罪过，不迎而自归？”兰芝惭阿母：“儿实无罪过。”阿母大悲摧68。 还家十余日，县令遣媒来。云有第三郎，窈窕69世无双。年始十八九，便言多令才70。 阿母谓阿女：“汝可去应之。” 阿女含泪答：“兰芝初还时，府吏见丁宁71，结誓不别离。今日违情义，恐此事非奇72。自可断来信73，徐徐更谓之74。” 阿母白媒人：“贫贱有此女，始适75还家门。不堪76吏人妇，岂合令郎君？幸可广问讯，不得便相许。” 媒人去数日，寻遣丞请还，说有兰家女，丞籍有宦官77。云有第五郎，娇逸78未有婚。遣丞为媒人，主簿79通语言。直说太守家，有此令郎君，既欲结大义，故遣来贵门。 阿母谢媒人：“女子先有誓，老姥岂敢言！” 阿兄得闻之，怅然心中烦。举言谓阿妹：“作计80何不量81！先嫁得府吏，后嫁得郎君，否泰82如天地，足以荣汝身。不嫁义郎83体，其往欲何云84？” 兰芝仰头答：“理实如兄言。谢家事夫婿，中道还兄门。处分85适86兄意，那得自任专！虽与府吏要87，渠会88永无缘。登即89相许和，便可作婚姻。“ 媒人下床去，诺诺复尔尔90。还部白府君91：“下官92奉使命，言谈大有缘93。”府君得闻之，心中大欢喜。视历94复开书，便利此月内，六合95正相应。良吉三十日，今已二十七，卿96可去成婚。交语97速装束，络绎如浮云。青雀白鹄舫98，四角龙子幡99。婀娜100随风转，金车玉作轮。踯躅101青骢马102，流苏103金镂鞍。赍104钱三百万，皆用青丝穿。杂彩105三百匹，交广106市鲑107珍。从人四五百，郁郁108登郡门。 阿母谓阿女：“适109得府君书，明日来迎汝。何不作衣裳？莫令事不举110！” 阿女默无声，手巾掩口啼，泪落便如泻。移我琉璃榻111，出置前窗下。左手持刀尺，右手执绫罗。朝成绣夹裙，晚成单罗衫。晻晻112日欲暝，愁思出门啼。 府吏闻此变，因求假暂归。未至二三里，摧藏113马悲哀。新妇识马声，蹑履相逢迎。怅然遥相望，知是故人来。举手拍马鞍，嗟叹使心伤：“自君别我后，人事不可量114。果不如先愿，又非君所详。我有亲父母115，逼迫兼弟兄116。以我应他人，君还何所望！” 府吏谓新妇：“贺卿得高迁！磐石方且厚，可以卒千年；蒲苇一时纫，便作旦夕间。卿当日胜贵117，吾独向黄泉！” 新妇谓府吏：“何意出此言！同是被逼迫，君尔妾亦然。黄泉下相见，勿违今日言！”执手分道去，各各还家门。生人作死别，恨恨118那可论？念与世间辞，千万不复全！ 府吏还家去，上堂拜阿母：“今日大风寒，寒风摧树木，严霜结庭兰。儿今日冥冥119，令母在后单120。故121作不良计122，勿复怨鬼神！命如南山石，四体123康且直124！” 阿母得闻之，零泪应声落：“汝是大家子，仕宦于台阁125。慎勿为妇死，贵贱情何薄126！东家有贤女，窈窕艳城郭，阿母为汝求，便复在旦夕。” 府吏再拜还，长叹空房中，作计乃尔立127。转头向户里，渐见愁煎迫。 其日牛马嘶，新妇入青庐128。奄奄129黄昏130后，寂寂人定初。“我命绝今日，魂去尸长留！”揽裙脱丝履，举身赴清池。 府吏闻此事，心知长别离。徘徊庭树下，自挂东南枝。 两家求合葬，合葬华山131傍。东西植松柏，左右种梧桐。枝枝相覆盖，叶叶相交通132。中有双飞鸟，自名为鸳鸯。仰头相向鸣，夜夜达五更。行人驻足133听，寡妇起彷徨。多谢134后世人，戒之慎勿忘！ [10]]]></content>
      <categories>
        <category>文言文</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

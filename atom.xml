<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>残桥断雪的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-08T07:46:16.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>laigang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>特征工程</title>
    <link href="http://yoursite.com/2019/09/04/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/04/特征工程/</id>
    <published>2019-09-04T07:41:56.000Z</published>
    <updated>2019-09-08T07:46:16.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本数值特征">1.基本数值特征</h3><ul><li><p>对于刚拿到的数据，先进行缺失值处理</p></li><li><p>对于离散值，我们常用 LabelEncoder OneHotEncoder来对其进行编码以方便识别。常用的为pandas中的<strong>get_dummies()</strong>方法，当然sklearn 也有对应的类</p></li><li><p>对于二值特征:Sklearn中的二值化类是<strong>Binarizer</strong>，当然Pandas直接判断也很方便</p></li><li><p>对于多项式特征:也就是多个特征指标的组合(一般支持向量机用的比较多，乘积、平方等等)，使用<strong>PolynomialFeatures</strong>来实现。</p></li><li><p>对于binning(连续)特征:可以做离散化，划分区间分成几个类(比如年龄)，可以直接写<strong>map()</strong>函数映射。比较常用的方法,可以直接试一试，效果不好说。</p></li><li><p>分位数切分: 四分位，二分位，四分之三分位等切分成离散的方式，常用pandans的<strong>quantile()</strong>方法，然后用<strong>qcut()</strong>的方法进行切分</p></li><li><p>对数变换(COX-BOX): 对于分布是正态分布假设的算法(可以用偏度来判定)，数据本身可能偏度很大，而做了对数变换有可能使得其更接近对数变换。使用numpy.log()即可。COX-BOX是另一种更复杂的对数变换，其目的也是让数据近似于正态分布。</p></li></ul><h3 id="日期特征处理">2.日期特征处理</h3><p>一般的日期转化为dataTime格式，可以直接把年月日拿出来用的数据(apply)。提取出年月日之后可以当成特征，也可以二次加工。比如四季、早晚、前半年、后半年等等。 整体的思路是:前期多提特征，后期再筛选。</p><h3 id="文本特征处理">3.文本特征处理</h3><p>文本特征的难度是如何让计算机认识这些文字，文字本身对于计算机来说很难提取出特征<br>可以使用<strong>nltk</strong>工具包进行预处理，具体使用应该专门学习<br>关于语句的编码，常用的有<em>词袋模型</em>(对输入的词进行编码，句子中出现的词表示为1，未出现的词表示为0，其实就是词汇分布表，并包含有词频，sklearn中有对应的<strong>CountVectorizer</strong>)</p><h3 id="时间序列的特征挖掘">4.时间序列的特征挖掘</h3><ol type="1"><li><p>统计特征 : 最大值(max)，最小值(min)，均值(mean)，中位数(median)，方差(variance)，标准差(standard variance)，偏度(skewness)，峰度(kurtosis)<br>关于偏度和峰度，它们是如下两个公式：</p><p><span class="math display">\[\mu\,=\,\frac{1}{T}\sum_{i=1}^{T}x_i\]</span> <span class="math display">\[\sigma^{2}\,=\,\sum_{i=1}^{T}\frac{1}{T}(x_i - \mu)^{2}\]</span> <span class="math display">\[skewness(X)\,=\,E[(\frac{X\,-\,\mu}{\sigma})^{3}]\,=\,\frac{1}{T}\,\sum_{i=1}^{T}\frac{(x_i\,-\,\mu)^3}{\sigma^{3}}\]</span> <span class="math display">\[kurtosis(X)\,=\,E[(\frac{X\,-\,\mu}{\mu})^4]\,=\,\frac{1}{T}\,\sum_{i=1}^{T}\frac{(x_i\,-\,\mu)^4}{\sigma^4}\]</span></p></li><li>熵特征<br>熵是衡量数据确定性和不确定性的指标，在相同的方差、均值和中位数的情况下，entropy越大，系统就越混乱。<br>entropy公式如下:<br><span class="math inline">\(entropy(X)\,=\,-\sum_{i=1}^{\infty}\,P\{x\,=\,x_i\}\,ln(P\{x\,=\,x_i\})\)</span><br>上面是信息论中基本的熵公式，下面介绍几个在时间序列中运用的熵:<ul><li>2.1 Binned Entropy<br>这种做法是把时间序列进行分桶的操作，计算每个桶内的熵，以此来衡量时间序列的集中程度<br>如果一个时间序列的 Binned Entropy 较大，说明这一段时间序列的取值是较为均匀的分布在<span class="math inline">\(\,min(X_T), max(X_T)\,\)</span>之间。如果取值较小，说明其取值是集中在某一段上的. <span class="math inline">\(binned entropy\,=\,-\sum_{k=0}^{min(maxbin,len(X))}\;p_k\,ln(p_k)\,\cdot\,1_{p_k&gt;0}\)</span></li><li>2.2 Approximate Entropy<br>这个指标可判断这个时间序列是具备某种趋势还是随机出现。AE这种方法是将一位空间中的时间序列提升到高维空间中，通过高维空间中向量的距离或者相似度来判断一维空间中是否存在某种趋势。算法大致如下:<ul><li>step1: 给定两个参数m,r .其中m表示取多长的子片段分析，r表示投射到高位时两向量是否相近的阈值。需要构造的m维向量如下:<br><span class="math inline">\(X_1(m)\,=\,(x_1,\cdots,x_m)\in\mathbb{R},\)</span><br><span class="math inline">\(X_i(m)\,=\,(x_i,\cdots,x_{m+i-1})\in\mathbb{R},\)</span><br><span class="math inline">\(X_{N-m+1}(m)\,=\,(x_{N-m+1},\cdots,x_N)\in\mathbb{R}.\)</span><br></li><li>step2: 通过上述m维向量可以计算出哪些向量和<span class="math inline">\(X_i(m)\)</span>相似: <span class="math inline">\(C_i^m(r)\,=\,(number\,of\,X_j(m)\,such\,that\,d(X_i(m),X_j(m)\,\leq\,r)/(N-m+1))\)</span><br>在这里，d可以选取<span class="math inline">\(L^1,L^2,L^P,L^\infty\)</span>范数，这里常用<span class="math inline">\(L^\infty\)</span>范数.</li><li>step3: 考虑函数:<br><span class="math inline">\(\Phi^m(r)\,=\,(N-m+1)^-1\:.\sum_{i=1}^{N-m+1}ln(C_i^m(r))\)</span><br></li><li>step4: Approximate Entropy可定义为:<br><span class="math inline">\(ApEn(m,r)\,=\,\Phi^m(r)-\Phi^{m+1}(r)\)</span></li><li>remark:<ol type="1"><li>m一般取值2或者3，r&gt;0, r需要根据具体的时间序列进行调整<br></li><li>如果某个时间序列有许多很相似或者重复的时间序列，那么他的Approximate Entropy就相对较小，反之就相对较大。</li></ol></li></ul></li><li>2.3. Sample Entropy<br>测试</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本数值特征&quot;&gt;1.基本数值特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于刚拿到的数据，先进行缺失值处理&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于离散值，我们常用 LabelEncoder OneHotEncoder来对其进行编码以方便识别。常用的为pandas中的&lt;s
      
    
    </summary>
    
      <category term="feature engineering" scheme="http://yoursite.com/categories/feature-engineering/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Word Embedding</title>
    <link href="http://yoursite.com/2019/08/30/Word-Embedding/"/>
    <id>http://yoursite.com/2019/08/30/Word-Embedding/</id>
    <published>2019-08-30T12:19:20.000Z</published>
    <updated>2019-09-10T12:12:59.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>核心问题：如何用一个vector表示单词？</p></blockquote><ol type="1"><li><p>1-of-N encoding<br>这是最简单的做法，相当于对所有的文字做了一个onehot编码，也就是用一个长度为N(N表示单词的个数)的向量来唯一的表示一个单词。</p><figure><img src="/2019/08/30/Word-Embedding/2019-08-30-20-33-07.png" alt="1-of-N encoding"><figcaption>1-of-N encoding</figcaption></figure><p>但是这种方法无法表达各个单词之间的关系，比如dog和cat都是动物，解决方法是给他们再做分类<br><img src="/2019/08/30/Word-Embedding/2019-08-30-20-36-19.png" alt="word class"></p><p>即使这样，这不能表达多个类别之间的关系。比如class1和class2之间其实是有关系的，因为动物是可以做跑跳的，显然这种硬分类也无法完全表达信息。</p></li><li><p>Word Embedding 把每一个Word都project到一个高维空间中去，这里的高维空间要比N低多得多。<br><img src="/2019/08/30/Word-Embedding/2019-08-30-20-46-27.png" alt="word embedding"><br>上图中各个点的关系可以通过在高位空间中的距离或者其他的指标来表示，也可以根据不同的标准来分类。<br>产生这种向量是非监督学习，我们只知道输入不知道输出<br><img src="/2019/08/30/Word-Embedding/2019-08-30-20-49-54.png" alt="unsupervised"><br><strong>可以使用auto-encoder吗？</strong></p><pre><code> 显然是不可以的，输入的是onehot编码，其实是学不到什么东西的。  </code></pre></li><li>如何通过Word Embedding 来学习上下文信息?<br><img src="/2019/08/30/Word-Embedding/2019-08-30-21-07-42.png" alt="机器上下文学习"><br>虽然机器不懂得蔡英文和马英九，但是根据上下文是可以把蔡英文和马英九归并成一类的。<ul><li>Count based（Glove Vector）<br>如果单词X，Y经常在一块出现，V(X)和V(Y)就会很接近。<br>具体做法是让V(X)和V(Y)的内积接近于X和Y共同出现的次数N<sub>x,y</sub><br><img src="/2019/08/30/Word-Embedding/2019-08-30-21-19-41.png" alt="Glove Vector"></li><li>Predition based<ul><li>这种方法对单词的表示仍然是onehot。该方法会训练一个NN，输入是一个onehot的单词编码，输出是一个概率向量，表示某个单词紧跟着该单词的可能性大小。<br><img src="/2019/08/30/Word-Embedding/2019-08-30-21-26-26.png" alt="predict based1"><br><img src="/2019/08/30/Word-Embedding/2019-08-30-21-27-15.png" alt="predict based2"><br>具体说来，其实是将上图中训练好的网络的第一层向量（Z）取出来作为该词汇的特征向量。<br></li><li><strong>为什么这种方法会奏效呢？</strong><br>中间的隐藏层，需要把同类或者相近的词汇投射到相同的区间。只有这样才能降低最终的loss。这种方法当然自动的考虑了上下文关系。<br></li><li><strong>只用一个单词来预测下一个单词肯定是不太现实， 所以引入了Sharing Parameters的模型</strong><br>其实就是用前N个词汇来预测下一个词汇<br><img src="/2019/08/30/Word-Embedding/2019-09-02-16-02-47.png" alt="Sharing Parameters"><br>如上图，这里前N个单词的权重是共享的，对应的连接处是相同的。其原因一是为了计算方便，二是为了保证同一个单词在不同位置输入得到的特征向量是相同的(<em>比如，就职前面的蔡英文和马英九不应该因为顺序不同而得到大相径庭的结果</em>)。<br>上面的公式给了一个等价变换。要得到单词的embedding，在训练完之后，只需要乘以那个W即可得到对应的embeddding。<br>另外在实际训练的时候，为了保持W相同，应该做到：<br><img src="/2019/08/30/Word-Embedding/2019-09-02-16-14-15.png" alt="make qual"><br>这个想法十分的巧妙，对反向传播做了小小的改动。<br></li><li>基本的训练过程<br><img src="/2019/08/30/Word-Embedding/2019-09-02-16-23-47.png" alt="基本训练过程"><br>当然变形的训练有好多种，他们的优势都各有千秋：<ol type="1"><li>Continues bug of word<br>之前是考虑上文，这里改成了考虑上下文<br><img src="/2019/08/30/Word-Embedding/2019-09-02-16-30-04.png" alt="CBOW"></li><li>Skip-gram<br>用中间的Word来预测上下文<br><img src="/2019/08/30/Word-Embedding/2019-09-02-16-32-26.png" alt="Skip-gram"></li></ol></li></ul></li></ul></li><li>应用<br>对于我们训练出来的词向量，还有很多有意思的操作。<ul><li>比如对两个词向量做减法，就能得到一些规律:<br><span class="math inline">\(V(hotter)-V(hot)\,\approx\,V(bigger)-V(big)\)</span><br><span class="math inline">\(V(Rome)-V(Italy)\,\approx\,V(Berlin)-V(Germany)\)</span><br><span class="math inline">\(V(king)-V(queen)\,\approx\,V(uncle)-V(aunt)\)</span><br>那么我们的机器就可以推测，罗马的意大利就和柏林的？？一样？ <span class="math inline">\(Compute\,V(Berlin)-V(Rome)+V(Italy)\)</span><br>之后就寻找最接近上述结果的词向量，就能找到答案<br></li><li>我们还可以做多语言的Word Embedding，中英文词汇翻译也可以做到<br><img src="/2019/08/30/Word-Embedding/2019-09-10-19-59-06.png" alt="Multi-lingual Embedding"><br>就像上面一样，我们可以学习一些对应关系，然后就可以进行翻译这种功能了。<br></li><li>除了对文字的Embedding，还可以对图像做<br><img src="/2019/08/30/Word-Embedding/2019-09-10-20-00-54.png" alt="Multi-domain Embedding"><br>这种方式可以用来做一些分类功能，因为传统的方法无法区分新增加的类别。这种方法即使没有这一类，至少也能区别出来不是已知的类别<br></li><li>我们甚至可以多document做Embedding，最简单的方法就是对文档做词袋，然后用auto-encoder。但是词袋无法考虑语言的顺序，会失去很多的信息。 下面是一些解决办法，需要深入研究可以直接去拜读。 <img src="/2019/08/30/Word-Embedding/2019-09-10-20-04-38.png" alt="Beyond Bag of Word"></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;核心问题：如何用一个vector表示单词？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;1-of-N encoding&lt;br&gt;
这是最简单的做法，相当于对所有的文字做了一个onehot编码，也就是用一个长度为N(N
      
    
    </summary>
    
      <category term="Unsupervised Learning" scheme="http://yoursite.com/categories/Unsupervised-Learning/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>小记</title>
    <link href="http://yoursite.com/2019/08/30/%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/30/小记/</id>
    <published>2019-08-30T07:30:56.000Z</published>
    <updated>2019-08-31T15:05:09.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>闲暇之余，想写篇日记，记录自己的所见所闻.</strong></p></blockquote><p>我的博客已经三个月没有更新东西了， 这个三个月可能发生了一些事情，也可能没有发生什么事情，但是终究还是发生了一些事情的。</p><h3 id="我太难了">&quot;我太难了&quot;</h3><p>&quot;我太难了&quot;， 当收到导师召回的消息时，这句话便脱口而出。纵观我没几天的暑假，这可能是最悲惨的消息了。我的暑假分布大概是这样的：98%的时间去练习科目三并最后准备考驾照，2%的时间去跪棚。整个暑假都在奔波中度过。<br>那天是台风利奇马来临的日子，刚开始它还是听和蔼的，只是淅淅沥沥的小雨，甚至给人一种 <em>渭城朝雨浥轻尘，客舍青青柳色新</em> 的错觉。我踏着单车，带着一种刚回家的喜悦奔向了科目三的练习地址。<br>“这不还在市区么，虽然是外环，有地图APP肯定没问题”， 自信满满的我如是道。<br>开始只是濛濛细雨，周围是一条小河，这种环境让我似乎穿梭在江南的小镇。我顺着怡人的柏油路，一边骑车一边哼着小曲赶往目的地。<br>“这地图为啥没标出来？”我一阵惊呼，这是到目的地的必经之路--一座桥。不幸的是这座桥似乎正在被修，因为它被封死了。<br>雨兄似乎也很给力，知道我认不得路的时候顺便增大了雨势。嗯，真的是加量不加价呢。 经过一番挣扎和一顿问路后，我终于曲曲折折的绕到了练车的地方。此种心酸不必多说，比如全身湿透这种基本操作，可以尽情脑补这种囧事。<br>总而言之，我还是到了，虽然晚了半个小时。 “XXX教练今天休息，你明天再来吧”。<br>当时我的心里其实是很平静的。“真正的勇士，敢于正视淋漓的大到暴雨，敢于直面被人放鸽子的惨淡人生”，这可能是我当初最好的感受。此时的雨兄可以称得上是大到暴雨了，我的心里也是大到暴雨。<br><strong>未完待遇</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;闲暇之余，想写篇日记，记录自己的所见所闻.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的博客已经三个月没有更新东西了， 这个三个月可能发生了一些事情，也可能没有发生什么事情，但是终究还是发生了一些事情的。&lt;/p&gt;
      
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Set Matrix Zeroes</title>
    <link href="http://yoursite.com/2019/05/27/Set-Matrix-Zeroes/"/>
    <id>http://yoursite.com/2019/05/27/Set-Matrix-Zeroes/</id>
    <published>2019-05-27T11:53:04.000Z</published>
    <updated>2019-08-30T01:49:29.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>给矩阵置0，就是找矩阵中为0的元素，将其同行同列置0,必须是就地算法（in-place）<br><a id="more"></a> 1. Example 1: - input:</p><pre><code>    [        [1,1,1],        [1,0,1],        [1,1,1]    ]- output:      [        [1,0,1],        [0,0,0],        [1,0,1]    ]</code></pre><ol start="2" type="1"><li>Example 2:<ul><li><p>input:</p>[ [0,1,2,0], [3,4,5,2], [1,3,1,5] ]<br></li><li><p>output:</p><p>[ [0,0,0,0], [0,4,5,0], [0,3,1,0] ]</p></li></ul></li></ol><h2 id="整体思路">整体思路</h2><h3 id="思路1.0版本朴素想法">思路1.0版本，朴素想法</h3><p>最朴素想法，先找为0的坐标，然后将其同行同列置0。这里有个小trick，找到为0的地方不能立即置0，下侧和右侧会导致判断失误。</p><h3 id="代码1.0">代码1.0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最朴素想法，先找，然后置0</span></span><br><span class="line">        <span class="comment">//注意：置0不能影响后面</span></span><br><span class="line">        HashSet&lt;Integer&gt; row = <span class="keyword">new</span> HashSet&lt;&gt;(), col = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="number">0</span>)&#123;<span class="comment">// 填充0</span></span><br><span class="line">                    row.add(i);</span><br><span class="line">                    col.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        置0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">                row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) matrix[i][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j :</span><br><span class="line">                col) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++)&#123;</span><br><span class="line">                matrix[k][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] nums :</span><br><span class="line">                matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="思路2.0版本">思路2.0版本</h3><p>上个版本肯定是不work的啦，毕竟最朴素想法时空只能打败30%左右的样子。作为一个<strong>never setter</strong>的人，怎么能容忍这么高的时空复杂度。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1559564397&amp;di=30cb28ffdd1897d3444284a8a587bc33&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fstatic.oneplus.cn%2Fdata%2Fattachment%2Fforum%2F201411%2F09%2F144717fimzeep1hynehbmr.png" alt="never settle"><br>上一种方法空间复杂度为O(m*n),我想办法降到O(1)。注意到当检查到matrix[i][j] == 0 ,不能直接所有行 列置0的原因是会影响下侧和右侧的判断。但是上侧和左侧不会影响，故我们不再使用HashMap，直接将matrix[i][0] = matrix[0][j] = 0 ,然后再检查一下行列开头即可。注意如果本来第0行或者第0列就有0，需要用一个flag来记忆一下，然后再判定置0。</p><h3 id="代码2.0">代码2.0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setZeroes2</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span> isCol = <span class="keyword">false</span>, isRow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;m; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[k][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                isCol = <span class="keyword">true</span>; <span class="comment">// 第一列应当置0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;n; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][k] == <span class="number">0</span>)&#123;</span><br><span class="line">                isRow = <span class="keyword">true</span>; <span class="comment">// 第一行应当置0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="number">0</span>)&#123;<span class="comment">// 填充0</span></span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n; ++j) matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;m; ++i) matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRow)   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;n; ++k) matrix[<span class="number">0</span>][k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCol)   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;m; ++k) matrix[k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] nums :</span><br><span class="line">                matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>中等题就是这样，解出来比较简单，但是想要拿个top还是比较难的。不管怎样，第二种解法也是top 98%的存在。那么就来个九转大肠鼓励一下自己吧！<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3477725904,3462716497&amp;fm=26&amp;gp=0.jpg" alt="九转大肠"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;给矩阵置0，就是找矩阵中为0的元素，将其同行同列置0,必须是就地算法（in-place）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>Regular Expression Matching</title>
    <link href="http://yoursite.com/2019/05/26/Regular-Expression-Matching/"/>
    <id>http://yoursite.com/2019/05/26/Regular-Expression-Matching/</id>
    <published>2019-05-26T12:29:25.000Z</published>
    <updated>2019-08-30T01:49:29.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>字符匹配问题</p><ul><li>用p来匹配s. p中可能包含. *</li><li>. 表示匹配任一个单一字符</li><li>* 表示匹配0到多个前一个字符</li><li>要求p和s匹配</li></ul><ol type="1"><li>Example 1:<ul><li>Input:<br>&gt; s=&quot;aa&quot;<br>&gt; p = &quot;a&quot;</li><li>Output: <strong>false</strong></li><li>Explanation:<br>&gt; &quot;a&quot; does not match the entire string &quot;aa&quot;</li></ul></li><li>Example 2:<ul><li>Input:<br>&gt; s=&quot;aa&quot;<br>&gt; p = &quot;a*&quot;</li><li>Output: <strong>true</strong></li><li>Explanation:<br>&gt; &quot;'*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;</li></ul></li><li>Example 3:<ul><li>Input:<br>&gt; s=&quot;aab&quot;<br>&gt; p = &quot;c*a*b&quot;</li><li>Output: <strong>true</strong></li><li>Explanation:<br>&gt; c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.</li></ul></li></ol><h2 id="思路">思路</h2><p>这是一道<strong>非常</strong>困难的题, 曾经害我苦思冥想了好几天。我刚开始甚至没想到居然能用DP解这个问题，后来苦苦求索翻阅leetcode一众大神的解释后才搞明白这个题用DP到底怎么搞<br>这是一道true false dp问题, dp[i][j] 表示了s前i个元素和p前j个元素的匹配情况<br>分情况讨论：</p><ol type="1"><li>如果s[i] == p [j] || p[j] == '.' 这时候完全就看前面的情况 dp[i][j] = dp[i-1][j-1]</li><li>如果s[i] != p [j]这个也要分情况<ul><li>2.1 如果p[j] == '*' (ba a* ab a*)<ul><li><p>2.1.1 若 p[j-1] != s[i] &amp;&amp; p[j-1] != '.'<br>此时, 由于上一个元素不匹配导致*无法复制，那么*只能让上一个元素清空:<br>&gt; dp[i][j] = dp[i][j-2]</p></li><li><p>2.1.2 除上面的情况外，即<em>可以复制上一个元素达到匹配的目的，当然也可以不复制上一个元素:<br>&gt; dp[i][j] = dp[i][j-2] (</em>上一个元素清空<em>) || dp[i][j-1] (</em>*只代表一个元素<em>) || dp[i-1][j] (</em>代表多个元素，如果在i前面都能和p匹配，那加一个自然也能匹配*)</p></li></ul></li><li>2.2 如果p[j] != '*'<br>&gt; dp[i][j] = false</li></ul></li></ol><p>特别解释一下，为什么在2.1.2中，当代表多个元素时，匹配的是dp[i-1][j]这个奇怪的搭配。让我们来举个栗子:<br><img src="https://cn.bing.com/th?id=OIP.KxkJwLabDhEU-WmW2u8LoAHaHQ&amp;pid=Api&amp;rs=1&amp;p=0" alt="举个栗子"> 假设我们的有<br>&gt; s: abbbbb<br>&gt; p: cb*</p><p>我们看到这里的*，实际上是代表了5个b,但是当我们求dp[i][j]的时候，我们无法得匹配完这些b之后前面的元素是否匹配，我们删掉这些b<br>&gt; s: a<br>&gt; p: c</p><p>也就是说，a,c是否匹配已经在之前迭代了。如何得知a,c的迭代位置呢？<br>&gt; dp[i][j] = dp[i-1][j] = …… = dp[i-6][j]</p><p>这是通过我们之前已经求到的结果迭代出来的，你会发现i递减的过程其实就是在找重复元素之前的元素，所以我们直接给出了dp[i-1][j]</p><h2 id="标准代码">标准代码</h2><p>其实如果能看懂上面的解释的话，代码不成问题，上面的解释已经接近于伪代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// s为空, p为空</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// s为空， p不空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j-<span class="number">2</span>]) dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//s不空，p空，直接默认false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>)==<span class="string">'.'</span>) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (p.charAt(j-<span class="number">2</span>)!=s.charAt(i-<span class="number">1</span>)&amp;&amp;p.charAt(j-<span class="number">2</span>)!=<span class="string">'.'</span>) dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                        <span class="keyword">else</span> dp[i][j] = dp[i][j-<span class="number">2</span>] || dp[i][j-<span class="number">1</span>] || dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>终于啃完这个头疼的问题了，看张图片奖励下自己吧 <img src="http://pic8.nipic.com/20100702/5155385_015834315161_2.jpg" alt="bing图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;字符匹配问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用p来匹配s. p中可能包含. *&lt;/li&gt;
&lt;li&gt;. 表示匹配任一个单一字符&lt;/li&gt;
&lt;li&gt;* 表示匹配0到多个前一个字符&lt;/li&gt;
&lt;li&gt;要求p和s匹配&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>ClimbingStairs</title>
    <link href="http://yoursite.com/2019/05/25/ClimbingStairs/"/>
    <id>http://yoursite.com/2019/05/25/ClimbingStairs/</id>
    <published>2019-05-25T13:57:17.000Z</published>
    <updated>2019-08-30T01:49:29.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>这道题是easy题：<br>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br>1. example1: Input: 2<br>Output: 2<br>Explanation:<br>1. 1 step + 1 step 2. 2 steps 2. example2:<br>Input: 3<br>Output: 3<br>Explanation:<br>1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step</p><h3 id="思路">思路</h3><p>这个就很简单了, 典型的计数型动态规划问题，常规做法：<br>记dp[n] 表示到高度n有dp[n]种方法，则dp[n] = dp[n-1]+dp[n-2]<br>边界：<br>dp[0] = 1 dp[1] = 2<br>计算顺序：从左到右</p><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">1</span>) dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;这道题是easy题：&lt;br&gt;
You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can eith
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>孔雀东南飞（中文测试）</title>
    <link href="http://yoursite.com/2019/05/24/%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/05/24/中文测试/</id>
    <published>2019-05-24T11:58:53.000Z</published>
    <updated>2019-08-30T01:49:29.561Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b5fc92eb75094b36cf9f13bfc2a517bc/d1160924ab18972b50566cfee5cd7b899e510a91.jpg" alt="孔雀东南飞插图"><figcaption>孔雀东南飞插图</figcaption></figure><ul><li><em>汉末建安中，庐江府小吏焦仲卿妻刘氏，为仲卿母所遣，自誓不嫁。其家逼之，乃投水而死。仲卿闻之，亦自缢于庭树。时人伤之，为诗云尔。</em><br><a id="more"></a></li><li>孔雀东南飞，五里一徘徊。<br></li><li>十三能织素6，十四学裁衣，十五弹箜篌7，十六诵诗书8。十七为君妇，心中常苦悲。君既为府吏，守节9情不移。贱妾留空房，相见常日稀。鸡鸣入机织，夜夜不得息。三日断10五匹，大人故嫌迟11。非为织作迟，君家妇难为！妾不堪12驱使，徒13留无所施14。便可白公姥15，及时相遣归<br></li><li>府吏得闻之，堂上启阿母：“儿已薄禄相16，幸复得此妇，结发17同枕席，黄泉共为友。共事二三年，始尔18未为久。女行无偏斜，何意致不厚19？”<br></li><li>阿母谓府吏：“何乃太区区20！此妇无礼节，举动自专由21。吾意久怀忿，汝岂得自由！东家有贤22女，自名秦罗敷，可怜23体无比，阿母为汝求。便可速遣之，遣去慎莫留！”<br></li><li>府吏长跪告：“伏惟24启阿母，今若遣此妇，终老不复取25！”<br></li><li>阿母得闻之，槌床26便大怒：“小子无所畏，何敢助妇语！吾已失恩义，会不相从许27！”<br></li><li>府吏默无声，再拜还入户。举言28谓新妇29，哽咽不能语：“我自不驱卿，逼迫有阿母。卿但暂还家，吾今且报府30。不久当归还，还必相迎取。以此下心意31，慎勿违吾语。”<br></li><li>新妇谓府吏：“勿复重纷纭32。往昔初阳岁33，谢34家来贵门。奉事循公姥，进止敢自专？昼夜勤作息35，伶俜萦苦辛36。谓言37无罪过，供养卒38大恩；仍更被驱遣，何言复来还！妾有绣腰襦39，葳蕤40自生光；红罗复斗帐，四角垂香囊；箱帘41六七十，绿碧青丝绳，物物各自异，种种在其中。人贱物亦鄙，不足迎后人42，留待作遗施43，于今无会因44。时时为安慰，久久莫相忘！”<br></li><li>鸡鸣外欲曙，新妇起严妆45。著我绣夹裙，事事四五通46。足下蹑47丝履，头上玳（dài）瑁（mào）48光。腰若流纨素，耳著明月珰49。指如削葱根，口如含朱丹。纤纤作细步，精妙世无双。<br></li><li>上堂拜阿母，阿母怒不止。“昔作女儿时50，生小出野里51。本自无教训，兼愧52贵家子。受母钱帛多，不堪母驱使。今日还家去，念母劳家里。”却53与小姑别，泪落连珠子。“新妇初来时，小姑始扶床；今日被驱遣，小姑如我长。勤心养公姥，好自相扶将54。初七及下九55，嬉戏莫相忘。”出门登车去，涕落百余行。<br></li><li>府吏马在前，新妇车在后。隐隐56何甸甸，俱会大道口。下马入车中，低头共耳语：“誓不相隔卿，且暂还家去；吾今且赴府，不久当还归。誓天不相负！”57<br></li><li>新妇谓府吏：“感君区区58怀！君既若见录59，不久望君来。君当作磐石，妾当作蒲苇，蒲苇纫60如丝，磐石无转移。我有亲父兄61，性行暴如雷，恐不任我意，逆62以煎我怀。”举手长劳劳63，二情同依依。<br></li><li>入门上家堂，进退无颜仪64。阿母大拊掌65，不图子自归66：“十三教汝织，十四能裁衣，十五弹箜篌，十六知礼仪，十七遣汝嫁，谓言无誓违67。汝今何罪过，不迎而自归？”兰芝惭阿母：“儿实无罪过。”阿母大悲摧68。<br></li><li>还家十余日，县令遣媒来。云有第三郎，窈窕69世无双。年始十八九，便言多令才70。<br></li><li>阿母谓阿女：“汝可去应之。”<br></li><li>阿女含泪答：“兰芝初还时，府吏见丁宁71，结誓不别离。今日违情义，恐此事非奇72。自可断来信73，徐徐更谓之74。”<br></li><li>阿母白媒人：“贫贱有此女，始适75还家门。不堪76吏人妇，岂合令郎君？幸可广问讯，不得便相许。”<br></li><li>媒人去数日，寻遣丞请还，说有兰家女，丞籍有宦官77。云有第五郎，娇逸78未有婚。遣丞为媒人，主簿79通语言。直说太守家，有此令郎君，既欲结大义，故遣来贵门。<br></li><li>阿母谢媒人：“女子先有誓，老姥岂敢言！”<br></li><li>阿兄得闻之，怅然心中烦。举言谓阿妹：“作计80何不量81！先嫁得府吏，后嫁得郎君，否泰82如天地，足以荣汝身。不嫁义郎83体，其往欲何云84？”<br></li><li>兰芝仰头答：“理实如兄言。谢家事夫婿，中道还兄门。处分85适86兄意，那得自任专！虽与府吏要87，渠会88永无缘。登即89相许和，便可作婚姻。“<br></li><li>媒人下床去，诺诺复尔尔90。还部白府君91：“下官92奉使命，言谈大有缘93。”府君得闻之，心中大欢喜。视历94复开书，便利此月内，六合95正相应。良吉三十日，今已二十七，卿96可去成婚。交语97速装束，络绎如浮云。青雀白鹄舫98，四角龙子幡99。婀娜100随风转，金车玉作轮。踯躅101青骢马102，流苏103金镂鞍。赍104钱三百万，皆用青丝穿。杂彩105三百匹，交广106市鲑107珍。从人四五百，郁郁108登郡门。<br></li><li>阿母谓阿女：“适109得府君书，明日来迎汝。何不作衣裳？莫令事不举110！”<br></li><li>阿女默无声，手巾掩口啼，泪落便如泻。移我琉璃榻111，出置前窗下。左手持刀尺，右手执绫罗。朝成绣夹裙，晚成单罗衫。晻晻112日欲暝，愁思出门啼。<br></li><li>府吏闻此变，因求假暂归。未至二三里，摧藏113马悲哀。新妇识马声，蹑履相逢迎。怅然遥相望，知是故人来。举手拍马鞍，嗟叹使心伤：“自君别我后，人事不可量114。果不如先愿，又非君所详。我有亲父母115，逼迫兼弟兄116。以我应他人，君还何所望！”<br></li><li>府吏谓新妇：“贺卿得高迁！磐石方且厚，可以卒千年；蒲苇一时纫，便作旦夕间。卿当日胜贵117，吾独向黄泉！”<br></li><li>新妇谓府吏：“何意出此言！同是被逼迫，君尔妾亦然。黄泉下相见，勿违今日言！”执手分道去，各各还家门。生人作死别，恨恨118那可论？念与世间辞，千万不复全！<br></li><li>府吏还家去，上堂拜阿母：“今日大风寒，寒风摧树木，严霜结庭兰。儿今日冥冥119，令母在后单120。故121作不良计122，勿复怨鬼神！命如南山石，四体123康且直124！”<br></li><li>阿母得闻之，零泪应声落：“汝是大家子，仕宦于台阁125。慎勿为妇死，贵贱情何薄126！东家有贤女，窈窕艳城郭，阿母为汝求，便复在旦夕。”<br></li><li>府吏再拜还，长叹空房中，作计乃尔立127。转头向户里，渐见愁煎迫。<br></li><li>其日牛马嘶，新妇入青庐128。奄奄129黄昏130后，寂寂人定初。“我命绝今日，魂去尸长留！”揽裙脱丝履，举身赴清池。<br></li><li>府吏闻此事，心知长别离。徘徊庭树下，自挂东南枝。<br></li><li>两家求合葬，合葬华山131傍。东西植松柏，左右种梧桐。枝枝相覆盖，叶叶相交通132。中有双飞鸟，自名为鸳鸯。仰头相向鸣，夜夜达五更。行人驻足133听，寡妇起彷徨。多谢134后世人，戒之慎勿忘！ [10]</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=b5fc92eb75094b36cf9f13bfc2a517bc/d1160924ab18972b50566cfee5cd7b899e510a91.jpg&quot; alt=&quot;孔雀东南飞插图&quot;&gt;&lt;figcaption&gt;孔雀东南飞插图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;汉末建安中，庐江府小吏焦仲卿妻刘氏，为仲卿母所遣，自誓不嫁。其家逼之，乃投水而死。仲卿闻之，亦自缢于庭树。时人伤之，为诗云尔。&lt;/em&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="文言文" scheme="http://yoursite.com/categories/%E6%96%87%E8%A8%80%E6%96%87/"/>
    
    
      <category term="文学" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
</feed>
